/*
 * motionSystem.c
 *
 *  Created on: Feb 25, 2020
 *      Author: xkacejs
 */

#include "motionSystem.h"


INSTR_INSTRUCTION* insList;


static uint32_t prevTime;
// TODO : how to set init Motion _instr ID;

void MOTION_Init(float tP,float tI,float tD,float aP,float aI,float aD){
	 INSTR_VelocityPeak	 	= 1500;	// mm/s , < 1000 ; 3500 > Translational
	 INSTR_AverageVelocity 	= 500; 	// mm/s , <  250 ; 1500 > Translational

	 INSTR_MaxAngularAccel 	= 80;	// rad/s/s
	 INSTR_MaxTransAccel 	= 9100;	// mm/s    1 g =~ 9807mm/s

	 INSTR_MaxAngVelocity 	= 2*PI;	// rad/s
	 INSTR_DefaultAngAccel 	= 50;	// rad/s/s
	 //in place turn acceleration


	insList = INSTR_InstrList;

	// set parameters;
	// angularController, translationalController;
	MOTOR_ControllerSet(&MOTION_translationController, tP, tI, tD);
	MOTION_translationController.Tx = 0;
	MOTION_translationController.maxU = 6000;
	MOTION_translationController.minU = -6000;
	MOTION_translationController.b = 1;
	MOTION_translationController.c = 1;

	MOTOR_ControllerSet(&MOTION_angularController, aP, aI, aD);
	MOTION_angularController.Tx = 0;
	MOTION_angularController.maxU = 80;//rad/s
	MOTION_angularController.minU = -80;
	MOTION_angularController.b = 1;
	MOTION_angularController.c = 1;



}



void printIstr(int id){
/*
	printf("%i,\t %i,\t %i,\t %i,\t %i,\t  %i,\t#  %i,\t %i,\t %i,\t %i,\t \n\r", id,\
				(int)insList[id].command,\
				(int)insList[id].trans.jerk,\
				(int)insList[id].trans.accel,\
				(int)insList[id].trans.speed,\
				(int)insList[id].trans.dist,\
				(int)insList[id].ang.jerk,\
				(int)insList[id].ang.accel,\
				(int)insList[id].ang.speed,\
				(int)insList[id].ang.dist );

*/
	}
void MOTION_Update(){
	/*
	 * This funciton do some magic, this function should be called periodically ! (~5ms)
	 *  1. chcek if was last instraction finished and new one should be processed
	 *  2. processed selectd instraction (MOTION_instrID)
	 */


	// calc period



	const uint32_t time = MAIN_GetMicros();
	MOTION_timePeriod = time-prevTime;
	prevTime = time;

	// Chcek if actual instraction was finished
	MOTION_ChcekForNewInstraction();

	// processed actauall instraction
	MOTION_ProcessedInstraction(&insList[MOTION_instrID]);


}

void MOTION_UpdateList(){
	/*
	 * This function wil chose if half of instruction list can be precaltulated
	 * precalculation of half can be done only if is processed  {<1; ListSize/2)}
	 *
	 *
	 */

	if(MOTION_instrID < INSTR_LIST_HALF_SIZE){
		// first half of list is processed, so second wil be updated
		if(MOTION_instrID > 0)
			INSTR_FillHalfList(1);
	}else{
		if(MOTION_instrID > INSTR_LIST_HALF_SIZE)
			INSTR_FillHalfList(0);
	}

}

void MOTION_ProcessedInstraction(INSTR_INSTRUCTION* instrActual){
	/*
	 * Do acceleration by highest non zero derivation
	 * calc velocity, set velocity to motors
	 *
	 */

	// TODO: adaptive pid regulator

	float overtakeAT = MOTION_CalcOvertaking(instrActual);
	//overtakeAT = 0;
	// Angular to Translational

	// speed up // accel som musel nahradit counter koli sumu, s accelero metrom by sa to mohlo odstranit
	const float newVelA = MOTION_StepVelocity(&(instrActual->ang),\
			SENSORS_angleVel, instrActual->ang.counter, overtakeAT);
	const float newVelT = MOTION_StepVelocity(&(instrActual->trans),\
			SENSORS_transVel, instrActual->trans.counter, -overtakeAT);

	// set volocity
	MOTION_SetVelocity(newVelT, newVelA);


}

static float MOTION_CalcOvertaking(INSTR_INSTRUCTION* instr){

	/*
	 * return actual overtake between angle and translational vectors;
	 * <-1 ; 1>
	 *  0 = vector are synchronize
	 * -1 = traslational vector already finish whole instraction, and rotational do not even start
	 *  1 = angular vector already finish whole instraction and rotational do not even start
	 */
	float measuredContinuanceAngle;
	float measuredContinuanceTrans;

	// Finding second highest non null derivation
	if(instr->ang.jerk != 0)
		measuredContinuanceAngle = SENSORS_angleAccel;
	else if(instr->ang.accel != 0)
		measuredContinuanceAngle = SENSORS_angleVel;
	else if(instr->ang.speed != 0)
		measuredContinuanceAngle = SENSORS_anglePos;
	else
		return 0; 	// not able to calc synchronization

	if(instr->trans.jerk != 0)
		measuredContinuanceTrans = SENSORS_transAccel;
	else if(instr->trans.accel != 0)
		measuredContinuanceTrans = SENSORS_transVel;
	else if(instr->trans.speed != 0)
		measuredContinuanceTrans = SENSORS_transPos;
	else
		return 0;	// not able to calc synchronization


	if(instr->ang.target - instr->ang.start == 0  ||  instr->trans.target - instr->trans.start == 0)
			return 0;


	const float relativeContinuanceAngle = (measuredContinuanceAngle - instr->ang.start)/ \
								(instr->ang.target - instr->ang.start);


	const float relativeContinuanceTrans = (measuredContinuanceTrans - instr->trans.start)/ \
								(instr->trans.target - instr->trans.start);




	if(relativeContinuanceTrans <= 1 && relativeContinuanceAngle <= 1 \
			|| relativeContinuanceTrans >= -1 || relativeContinuanceAngle >= -1)
		return relativeContinuanceAngle - relativeContinuanceTrans;
	else
		return 0;

}

static float MOTION_StepVelocity(struct _INS* insAct, float fbVelocity, float fbAccel, float overtake){
	/*
	 *
	 * This function  return velocity which should controller try to achive in one period
	 * It speed-up/down depending on instraction jerk and accel.
	 *
	 * overtake = <-1;1> ; if over take is > 0 make slower speed-up
	 *
	 * insAct->counter is used becouse of bad feedback
	 */


	overtake = (overtake<0)? 0: overtake; // <0;1>
	const float synchCorrection = 1 - overtake; // <1;0>


	if(insAct->jerk != 0){

		//========
		insAct->counter += insAct->jerk * MOTION_timePeriod *synchCorrection;

		// overshoot protection
		// is jerk positve? is accel more then target accel?
		if(insAct->jerk > 0 && insAct->counter > insAct->accel)
			insAct->counter = insAct->accel;
		if(insAct->jerk < 0 && insAct->counter < insAct->accel)
			insAct->counter = insAct->accel;
		//========

		fbVelocity += insAct->counter * MOTION_timePeriod; 		// accel is growing

		if(fbAccel > 0 && fbVelocity > insAct->speed)
			fbVelocity = insAct->speed;
		if(fbAccel < 0 && fbVelocity < insAct->speed)
			fbVelocity = insAct->speed;

		return fbVelocity;

	} else if (insAct->accel !=0){

		fbVelocity += insAct->accel * MOTION_timePeriod *synchCorrection;//accle is const

		if(fbAccel > 0 && fbVelocity > insAct->speed)
			fbVelocity = insAct->speed;
		if(fbAccel < 0 && fbVelocity < insAct->speed)
			fbVelocity = insAct->speed;

		return fbVelocity;
	}else
		return insAct->speed * synchCorrection;


}

void MOTION_ChcekForNewInstraction(){
	/*
	 * Chcek if finishing condition was set
	 */

	volatile uint8_t NewInstraction  = 0; // if variable is 1 id in list will be moved

	/*
	 * TOTO BOLO NA RYCHLO SPRVENE TU TREBA ZISKAVAT DRUHU NAJVYSIU dt
	 */

	const float distTrans = SENSORS_transPos;
	const float distAng	  = SENSORS_angleAccel;

	printf("%i, \t %i \r\n", (int)SENSORS_transVel, (int)insList[MOTION_instrID].trans.speed);

	if( insList[MOTION_instrID].trans.speed != 0 && distTrans >= insList[MOTION_instrID].trans.target)
		NewInstraction = 1;

	if( insList[MOTION_instrID].ang.speed != 0 && distAng >= insList[MOTION_instrID].ang.target)
		NewInstraction = 1;

	if( insList[MOTION_instrID].ang.speed == 0 && insList[MOTION_instrID].trans.speed == 0)
		NewInstraction = 1;

	if(NewInstraction == 1)	{

		//cyclick list

		//TODO : confirm that half-list was precalculated,
		// linear compare of second hights derivation


		// move circularly id
		MOTION_MoveInstrId();

		// TODO tu by si mal dat druhu najvysie derivaciu na start a target

		insList[MOTION_instrID].trans.target = distTrans + insList[MOTION_instrID].trans.dist;
		insList[MOTION_instrID].ang.target = distAng + insList[MOTION_instrID].ang.dist;
		insList[MOTION_instrID].trans.start = distTrans;
		insList[MOTION_instrID].ang.start = distAng;


	}
}

void MOTION_resetList(int id){
	insList[id].command 	 = CMD_STOP;

	insList[id].trans.counter= 0;
	insList[id].trans.dist   = 0;
	insList[id].trans.speed  = 0;
	insList[id].trans.accel  = 0;
	insList[id].trans.jerk   = 0;

	insList[id].ang.counter  = 0;
	insList[id].ang.dist     = 0;
	insList[id].ang.speed    = 0;
	insList[id].ang.accel    = 0;
	insList[id].ang.jerk     = 0;

}

void MOTION_uTurnTest(){


	const int vel = 100;

	int id = 0;
	MOTION_resetList(id);
	insList[id].command 	 = CMD_STOP;
	insList[id].trans.dist   = 0;
	insList[id].trans.speed  = 0;
	insList[id].trans.accel  = 0;
	id++;


	MOTION_resetList(id);
	insList[id].command 	 = CMD_FWD0 + 1;
	insList[id].trans.dist   = 1* CELL_DIMENSION*SQRT2;
	insList[id].trans.speed  = 100;
	insList[id].trans.accel  = 0;
	id++;
				// list,	 distance, radius, velocity ,
	INSTR_AddArc(&insList[id], 180, 90, 100, CMD_SS180L);
	id +=4;


	MOTION_resetList(id);
	insList[id].command 	 = CMD_FWD0 + 1;
	insList[id].trans.dist   = 1* CELL_DIMENSION*SQRT2;
	insList[id].trans.speed  = 100;
	insList[id].trans.accel  = 0;
	id++;


	MOTION_resetList(id);
	insList[id].command 	 = CMD_STOP;
	insList[id].trans.dist   = 0;
	insList[id].trans.speed  = 0;
	insList[id].trans.accel  = 0;
	id++;


	MOTION_resetList(id);
	INSTR_InstrListUsedInstr[0] = id-1;
	INSTR_InstrListUsedInstr[1] = 0;

}

static void MOTION_MoveInstrId(){
	/*
	 *  circularly move MOTION_instrID
	 *  it chcek if THE new instruction was pre-calculated
	 *   (there maybe was not enought space in half list
	 *   to translate full command, so list need to be cut)
	 *
	 */

	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// TOTO SOM TU DAL LEN KOLI LENIVEMU TESTOVANIU
	// 			TU JE CHYBA AK JE NIEKDE CHYBA ERROR
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1


	MOTION_instrID = (MOTION_instrID >= 7)? 7 : MOTION_instrID+1;

	return;
	/// TOTO JE LENIVOST IBA


	// circular move
	MOTION_instrID = (MOTION_instrID + 1) % (2*INSTR_LIST_HALF_SIZE);

	// does it use firs or second half of list
	const uint8_t halfList = (MOTION_instrID < INSTR_LIST_HALF_SIZE)? 0 : 1 ;

	//id in half of the list
	const uint8_t relativeID = MOTION_instrID - halfList * INSTR_LIST_HALF_SIZE;

	// example: want to go to 3rd instr (relID =  2), but pre-calculated was only 2 instr
	if( relativeID >= INSTR_InstrListUsedInstr[halfList]){
		// new instruction was not pre-calculated
		// so go to begin of other half
		MOTION_instrID = (halfList == 0 )? INSTR_LIST_HALF_SIZE : 0 ;
	}

}

void MOTION_SetVelocity(float transV, float angularV){
	/*
	 * translational velocity and angular velocity will be processed
	 * though controller and motorVelocity R and L wil be calculated
	 *
	 */


	// PID update

	MOTOR_ControllerUpdate(&MOTION_angularController, angularV, SENSORS_angleVel);
	MOTOR_ControllerUpdate(&MOTION_translationController, transV, SENSORS_transVel);

	float velL_req = MOTION_translationController.U - MOTION_angularController.U*WHEEL_PITCH/2;
	float velR_req = MOTION_translationController.U + MOTION_angularController.U*WHEEL_PITCH/2;

	if(transV == 0 && angularV==0)
		 velL_req = velR_req = 0;

	//float velL_req = transV - angularV*WHEEL_PITCH;
	//float velR_req = transV + angularV*WHEEL_PITCH;


	MOTOR_SetVelocity(MOTOR_ML, velL_req);
	MOTOR_SetVelocity(MOTOR_MR, velR_req);

}
